# -*- coding: utf-8 -*-
"""rrt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ofu6RQJgHyT1awBRCS6qRFLJZs9U_f0
"""

class Node:
    def __init__(self, row, col):
        self.row = row        # coordinate
        self.col = col        # coordinate
        self.parent = None    # parent node
        self.cost = 0.0       # cost


# Class for RRT
class RRT:
    # Constructor
    def __init__(self, map_array, start, goal):
        self.map_array = map_array            # map array, 1->free, 0->obstacle
        self.size_row = map_array.shape[0]    # map size
        self.size_col = map_array.shape[1]    # map size

        self.start = Node(start[0], start[1]) # start node
        self.goal = Node(goal[0], goal[1])    # goal node
        self.vertices = []                    # list of nodes
        self.found = False                    # found flag
        

    def init_map(self):
        '''Intialize the map before each search
        '''
        self.found = False
        self.vertices = []
        self.vertices.append(self.start)

    
    def dis(self, node1, node2):
        '''Calculate the euclidean distance between two nodes
        arguments:
            node1 - node 1
            node2 - node 2

        return:
            euclidean distance between two nodes
        '''
        
        dx = node1.row - node2.row
        dy = node1.col - node2.col
        d = math.hypot(dx, dy)

        return d

    
    def check_collision(self, node1, node2):
        '''Check if the path between two nodes collide with obstacles
        arguments:
            node1 - node 1
            node2 - node 2

        return:
            True if the new node is valid to be connected
        '''
        ### YOUR CODE HERE ###
        sx = node1.row
        sy = node1.col
        gx = node2.row
        gy = node2.col
        x = sx
        y = sy
        dx = gx - sx
        dy = gy - sy
        theta = math.atan2(gy - sy, gx - sx)
        d = math.hypot(dx, dy)

        n_step = 5*int(d)
        collision = True
        for i in range(n_step):
            D = d*(i+1)/n_step
            x = sx+int(D * math.cos(theta))
            y = sy+int(D * math.sin(theta))
            if (map_array[int(x),int(y)] == 0):
              collision = False
        return collision  


    def get_new_point(self, goal_bias):
        '''Choose the goal or generate a random point
        arguments:
            goal_bias - the possibility of choosing the goal instead of a random point

        return:
            point - the new point
        '''
        ### YOUR CODE HERE ###
        rand_pts = np.random.randint(300, size=(2, 100))
        goal_chances = int(goal_bias*100)
        for i in range (goal_chances):
          rand_pts[0,i] = self.goal.row
          rand_pts[1,i] = self.goal.col 

        chosen_point_num = np.random.randint(100,size = (1,1))

        return Node(rand_pts[0,chosen_point_num],rand_pts[1,chosen_point_num])

    def get_nearest_node(self, point):
        '''Find the nearest node in self.vertices with respect to the new point
        arguments:
            point - the new point

        return:
            the nearest node
        '''
        ### YOUR CODE HERE ###
        nodes = self.vertices  
        d = np.zeros([1,len(nodes)])
        for i in range (len(nodes)):
          d[0,i] = self.dis(nodes[i], point)
        nnode_n = np.argmin(d)
        return self.vertices[nnode_n]


    def get_neighbors(self, new_node, neighbor_size):
        '''Get the neighbors that are within the neighbor distance from the node
        arguments:
            new_node - a new node
            neighbor_size - the neighbor distance

        return:
            neighbors - a list of neighbors that are within the neighbor distance 
        '''
        ### YOUR CODE HERE ###

        neighbors = []
        nodes = self.vertices  
        d = np.zeros([1,len(nodes)])
        for i in range (len(nodes)):
          if self.dis(nodes[i], new_node) <= neighbor_size:
            neighbors.append(nodes[i])
        return neighbors
            

    def rewire(self, new_node, neighbors):
        '''Rewire the new node and all its neighbors
        arguments:
            new_node - the new node
            neighbors - a list of neighbors that are within the neighbor distance from the node

        Rewire the new node if connecting to a new neighbor node will give least cost.
        Rewire all the other neighbor nodes.
        '''
        ### YOUR CODE HERE ###

        sorted_neighbors = []
        free_neighbors=[]
        
        if len(neighbors) > 0: 
          cost_neighbours = np.ones([len(neighbors),1])
          i = 0
          for neighbor in neighbors:
              cost_neighbours[i,0] = float(neighbor.cost) + float(self.dis(new_node,neighbor))
              i+=0

          min_cost_n = np.argsort(cost_neighbours)
          
          for i in range(len(neighbors)):
              sorted_neighbors.append(neighbors[min_cost_n[i,0]])

          for i in range (len(sorted_neighbors)): 
              if not self.check_collision(new_node,sorted_neighbors[i]):
                  new_node.parent = sorted_neighbors[i]
                  new_node.cost = float(cost_neighbours[i])
                  self.vertices.append(new_node)
                  break
          for j in range(i+1,len(sorted_neighbors),1):
            if not self.check_collision(new_node,sorted_neighbors[j]):
              free_neighbors.append(sorted_neighbors[j])

          for i in range(len(free_neighbors)):          
 
              if ((free_neighbors[i].cost > float(self.dis(new_node,free_neighbors[i]))) and (not self.check_collision(new_node, free_neighbors[i]))):
                  free_neighbors[i].parent = new_node
                  free_neighbors[i].cost = float(self.dis(new_node,free_neighbors[i])) + float(new_node.cost)
    def draw_map(self):
        '''Visualization of the result
        '''
        # Create empty map
        fig, ax = plt.subplots(1)
        img = 255 * np.dstack((self.map_array, self.map_array, self.map_array))
        ax.imshow(img)

        # Draw Trees or Sample points
        for node in self.vertices[1:-1]:
            plt.plot(node.col, node.row, markersize=3, marker='o', color='y')
            plt.plot([node.col, node.parent.col], [node.row, node.parent.row], color='y')
        
        # Draw Final Path if found
        if self.found:
            cur = self.goal
            while cur.col != self.start.col and cur.row != self.start.row:
                plt.plot([cur.col, cur.parent.col], [cur.row, cur.parent.row], color='b')
                cur = cur.parent
                plt.plot(cur.col, cur.row, markersize=3, marker='o', color='b')

        # Draw start and goal
        plt.plot(self.start.col, self.start.row, markersize=5, marker='o', color='g')
        plt.plot(self.goal.col, self.goal.row, markersize=5, marker='o', color='r')

        # show image
        plt.show()

    def RRT(self, n_pts=2000):
      '''RRT main search function
      arguments:
          n_pts - number of points try to sample,
                  not the number of final sampled points

      In each step, extend a new node if possible, and check if reached the goal
      '''
      # Remove previous result
      self.init_map()

      ### YOUR CODE HERE ###
      max_step = 15
      goal_bias = 0.1

      for iterations in range(2000):

        new_point = self.get_new_point(goal_bias)
        nearest_node = self.get_nearest_node(new_point)
        d = self.dis(new_point, nearest_node)

        if d <= max_step:
          new_node = new_point
        else:
          sx = nearest_node.row
          sy = nearest_node.col
          gx = new_point.row
          gy = new_point.col
          x = sx
          y = sy
          dx = gx - sx
          dy = gy - sy
          theta = math.atan2(gy - sy, gx - sx)
          d = math.hypot(dx, dy)

          if self.check_collision(Node(sx+int(d/2 * math.cos(theta)),int(sy+d/2 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/2 * math.cos(theta)),sy+int(d/2 * math.sin(theta)))
          elif self.check_collision(Node(sx+int(d/5 * math.cos(theta)),int(sy+d/5 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/3 * math.cos(theta)),sy+int(d/3 * math.sin(theta)))
          elif self.check_collision(Node(sx+int(d/7 * math.cos(theta)),sy+int(d/7 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/4 * math.cos(theta)),sy+int(d/4 * math.sin(theta)))
          else: continue 

          self.vertices.append(new_node)
          new_node.parent = nearest_node
          new_node.cost = self.dis(nearest_node,new_node) + new_node.parent.cost 
          goal_dis = self.dis(new_node,self.goal)
          if goal_dis < max_step:
              goal_coll = self.check_collision(new_node,self.goal)
              if goal_coll == True:
                  self.found=True
                  self.vertices.append(self.goal)
                  self.goal.parent = new_node
                  self.goal.cost = goal_dis+new_node.cost
                  
                  break 

      if self.found:
        steps = len(self.vertices) - 2
        length = self.goal.cost
        print("It took %d nodes to find the current path" % steps)
        print("The path length is %.2f" % length)
      else:
        print("No path found")

      # Draw result
      self.draw_map()


    def RRT_star(self, n_pts=1000, neighbor_size=40):
        '''RRT* search function
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points
            neighbor_size - the neighbor distance
        
        In each step, extend a new node if possible, and rewire the node and its neighbors
        '''
        # Remove previous result
        self.init_map()

        ### YOUR CODE HERE ###

        # In each step,
        # get a new point, 
        # get its nearest node, 
        # extend the node and check collision to decide whether to add or drop,
        # if added, rewire the node and its neighbors,
        # and check if reach the neighbor region of the goal if the path is not found.

        goal_bias = 0.05 # Goal bias is selected as 0.05 which is 5% probability the the new point selected will be the gaol point.
        step_len = 10 # Maximum Length of each step in the direction of the generated random point
        dist_goal = 10 # the distance metric representing the surrounding the goal region

        for i in range(n_pts):
            new_point = self.get_new_point(goal_bias)
            nearest_node = self.get_nearest_node(new_point)
            d = self.dis(new_point, nearest_node)
            sx = nearest_node.row
            sy = nearest_node.col
            gx = new_point.row
            gy = new_point.col
            x = sx
            y = sy
            dx = gx - sx
            dy = gy - sy
            theta = math.atan2(gy - sy, gx - sx)
            d = math.hypot(dx, dy)
            new_node = Node(sx+int(d/3 * math.cos(theta)),sy+int(d/3 * math.sin(theta)))
            collision = self.check_collision(nearest_node,new_node)
         
            if collision == False:
                neighbors = self.get_neighbors(new_node,neighbor_size)
                if (len(neighbors) > 0):
                  self.rewire(new_node,neighbors)
                  #print(neighbors[0].cost)
            else:
                continue

            distance_to_goal = self.dis(new_node,self.goal)
            
            if distance_to_goal <= dist_goal and self.check_collision(new_node,self.goal) is False:
                self.goal.cost = new_node.cost + distance_to_goal
                self.goal.parent = new_node
                self.vertices.append(self.goal)
                self.found = True
        

        # Output
        if self.found:
            steps = len(self.vertices) - 2
            length = self.goal.cost
            print("It took %d nodes to find the current path" %steps)
            print("The path length is %.2f" %length)
        else:
            print("No path found")

        # Draw result
        self.draw_map()