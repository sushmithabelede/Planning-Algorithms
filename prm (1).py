# -*- coding: utf-8 -*-
"""prm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1twOhRFXBCTwc-03aZkwFpZmvG5Bg-UIK
"""

# -*- coding: utf-8 -*-
"""PRM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-w4ClVd9DM7dutOdfjsVY-812Mhw97B3
"""

# Standard Algorithm Implementation
# Sampling-based Algorithms PRM

import matplotlib.pyplot as plt
import numpy as np
from numpy.random import randint 
from PIL import Image
import random
import math
import networkx as nx
import matplotlib.pyplot as plt
from scipy import spatial


def load_map(file_path, resolution_scale):
    ''' Load map from an image and return a 2D binary numpy array
        where 0 represents obstacles and 1 represents free space
    '''
    # Load the image with grayscale
    img = Image.open(file_path).convert('L')
    # Rescale the image
    size_x, size_y = img.size
    new_x, new_y  = int(size_x*resolution_scale), int(size_y*resolution_scale)
    img = img.resize((new_x, new_y), Image.ANTIALIAS)

    map_array = np.asarray(img, dtype='uint8')
    x = np.where(map_array == 1)
    # Get bianry image
    threshold = 127
    map_array = 1 * (map_array > threshold)

    # Result 2D numpy array
    return map_array


# Class for PRM
class PRM:
    # Constructor
    def __init__(self, map_array):
        self.map_array = map_array            # map array, 1->free, 0->obstacle
        self.size_row = map_array.shape[0]    # map size
        self.size_col = map_array.shape[1]    # map size
    # Result 2D numpy array

        self.samples = []                     # list of sampled points
        self.graph = nx.Graph()               # constructed graph
        self.path = []                        # list of nodes of the found path


    def check_collision(self, p1, p2):
        '''Check if the path between two points collide with obstacles
        arguments:
            p1 - point 1, [row, col]
            p2 - point 2, [row, col]

        return:
            True if there are obstacles between two points
        '''
        ### YOUR CODE HERE ###
        ## CALCULATING IF THERE ARE ANY OSBTACLES BETWEEK GIVEN TWO NODES ## 
        sx = p1[0]
        sy = p1[1]
        gx = p2[0]
        gy = p2[1]
        x = sx
        y = sy
        dx = gx - sx
        dy = gy - sy
        theta = math.atan2(gy - sy, gx - sx) #angle the connecting line makes with the horizontal
        d = math.hypot(dx, dy)

        n_step = 5*int(d) # taking a small step size here hence, number of steps to reach the next node form the current node is kept higher
        collision = True
        for i in range(n_step):
            D = d*(i+1)/n_step
            x = sx+int(D * math.cos(theta)) #this is the x cordinate of the nodes in between
            y = sy+int(D * math.sin(theta)) #this is the y cordinate of the nodes in between
            if ((int(x) < 300) and (int(y) < 300) ):
              if (map_array[int(x),int(y)] == 0):
                collision = False
        return collision 



    def dis(self, point1, point2):
        '''Calculate the euclidean distance between two points
        arguments:
            p1 - point 1, [row, col]
            p2 - point 2, [row, col]

        return:
            euclidean distance between two points
        '''
        ### YOUR CODE HERE ###
        dx = point1[0] - point2[0]
        dy = point1[1] - point2[1]
        d = math.hypot(dx, dy) #calculating sqrt(dx^2+dy^2)

        return d


    def uniform_sample(self, n_pts):
        '''Use uniform sampling and store valid points
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points

        check collision and append valide points to self.samples
        as [(row1, col1), (row2, col2), (row3, col3) ...]
        '''
        # Initialize graph
        self.graph.clear()

        ### YOUR CODE HERE ###
        self.graph.clear()
        
        a = [];
        x_o = 0
        y_o = 0
        row = 300 
        col = 300
        c = 0
        x_all = [0 for x in range(1000)] 
        y_all = [0 for x in range(1000)] 
        x_i = 0
        for i in range(60):
          y_i = y_o+int(row/15)*i
          if (y_i < col):
            if map_array[row-1, y_i] == 1:
              self.samples.append((row-1, y_i))         
          for j in range(60):
              x_i = x_o+ int(col/15)*j  
              if ((x_i < row) and (y_i < col)):
                if ( (x_i >= 0) and (y_i >= 0)):
                  if map_array[x_i, y_i] == 1:
                    x_all[c] = x_i
                    c += 1
                    self.samples.append((x_i, y_i))
        args_n = np.argsort(np.unique(x_all))
        xu = np.unique(x_all)
        for i in range(xu.size):
          if map_array[xu[i],  col-1] == 1:
            self.samples.append((xu[i], col-1))    


        
    def random_sample(self, n_pts):
        '''Use random sampling and store valid points
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points

        check collision and append valide points to self.samples
        as [(row1, col1), (row2, col2), (row3, col3) ...]
        '''
        # Initialize graph
        self.graph.clear()

        ### YOUR CODE HERE ###
        rand_array = np.random.randint(300, size=(2, 500))
        for i in range(500):
          if map_array[rand_array[0, i],rand_array[1,i]] == 1:     
            self.samples.append((rand_array[0, i], rand_array[1,i]))


    def gaussian_sample(self, n_pts):
        '''Use gaussian sampling and store valid points
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points

        check collision and append valide points to self.samples
        as [(row1, col1), (row2, col2), (row3, col3) ...]
        '''
        # Initialize graph
        self.graph.clear()

        ### YOUR CODE HERE ###
        rand_array = np.random.randint(300, size=(2, 1000))
        for i in range(1000):
          #random.seed(i)
          sigma = 20 #np.random.randint(50,size=(1))
          if (sigma != 0):
            x_i = int(np.random.normal(rand_array[0,i], sigma, 1))
            y_i = int(np.random.normal(rand_array[1,i], sigma, 1))
            if ((x_i < 300) and (y_i < 300)):
              if ( (x_i >= 0) and (y_i >= 0)):
                if (map_array[x_i,y_i] != map_array[rand_array[0,i],rand_array[1,i]]) :
                  if (map_array[x_i,y_i] == 1): 
                    self.samples.append((x_i, y_i))
                  elif map_array[ rand_array[0,i] , rand_array[1,i] ] == 1 :
                    self.samples.append((rand_array[0,i], rand_array[1,i]))

    def bridge_sample(self, n_pts):
        '''Use bridge sampling and store valid points
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points

        check collision and append valide points to self.samples
        as [(row1, col1), (row2, col2), (row3, col3) ...]
        '''
        # Initialize graph
        self.graph.clear()

        ### YOUR CODE HERE ###
        rand_array = np.random.randint(300, size=(2, n_pts))
        for i in range(1000):
          #random.seed(i)
          sigma = 100 #np.random.randint(50,size=(1))
          if (sigma != 0):
            x_i = int(np.random.normal(rand_array[0,i], sigma, 1))
            y_i = int(np.random.normal(rand_array[1,i], sigma, 1))
   
            if ((x_i< 300) and (y_i< 300) ):
              if ( (x_i>= 0) and (y_i>= 0)):
                if (self.map_array[rand_array[0,i],rand_array[1,i]] ==1) :

                    mid_x = int((x_i+ rand_array[0,i])/2)
                    mid_y = int((y_i+ rand_array[1,i])/2)

                    if (map_array[mid_x,mid_y] == 1) :
                      self.samples.append((mid_x, mid_y))


    def draw_map(self):
        '''Visualization of the result
        '''
        # Create empty map
        fig, ax = plt.subplots()
        img = 255 * np.dstack((self.map_array, self.map_array, self.map_array))
        ax.imshow(img)

        # Draw graph
        # get node position (swap coordinates)
        node_pos = np.array(self.samples)[:, [1, 0]]
        pos = dict( zip( range( len(self.samples) ), node_pos) )
        pos['start'] = (self.samples[-2][1], self.samples[-2][0])
        pos['goal'] = (self.samples[-1][1], self.samples[-1][0])
        
        # draw constructed graph
        nx.draw(self.graph, pos, node_size=3, node_color='y', edge_color='y' ,ax=ax)

        # If found a path
        if self.path:
            # add temporary start and goal edge to the path
            final_path_edge = list(zip(self.path[:-1], self.path[1:]))
            nx.draw_networkx_nodes(self.graph, pos=pos, nodelist=self.path, node_size=8, node_color='b')
            nx.draw_networkx_edges(self.graph, pos=pos, edgelist=final_path_edge, width=2, edge_color='b')

        # draw start and goal
        nx.draw_networkx_nodes(self.graph, pos=pos, nodelist=['start'], node_size=12,  node_color='g')
        nx.draw_networkx_nodes(self.graph, pos=pos, nodelist=['goal'], node_size=12,  node_color='r')

        # show image
        plt.axis('on')
        ax.tick_params(left=True, bottom=True, labelleft=True, labelbottom=True)
        plt.show()


    def sample(self, n_pts=1000, sampling_method="uniform"):
        '''Construct a graph for PRM
        arguments:
            n_pts - number of points try to sample, 
                    not the number of final sampled points
            sampling_method - name of the chosen sampling method

        Sample points, connect, and add nodes and edges to self.graph
        '''
        # Initialize before sampling
        self.samples = []
        self.graph.clear()
        self.path = []

        # Sample methods
        if sampling_method == "uniform":
            self.uniform_sample(n_pts)
        elif sampling_method == "random":
            self.random_sample(n_pts)
        elif sampling_method == "gaussian":
            self.gaussian_sample(n_pts)
        elif sampling_method == "bridge":
            self.bridge_sample(n_pts)

        ### YOUR CODE HERE ###

        # Find the pairs of points that need to be connected
        # and compute their distance/weight.
        # Store them as
        # pairs = [(p_id0, p_id1, weight_01), (p_id0, p_id2, weight_02), 
        #          (p_id1, p_id2, weight_12) ...]
        pairs = []
        pairs_id = []
        radius = 30
        positions = np.array(self.samples)
        kdtree = spatial.KDTree(positions)
        pairs_kd = kdtree.query_pairs(radius)
        p = []

        for p in pairs_kd:
          p1 = self.samples[p[0]]
          p2 = self.samples[p[1]] 
          if self.check_collision(p1,p2):
            pairs_id.append(p[0])
            pairs_id.append(p[1])
            weight=self.dis(p1,p2)
            pairs.append((p[0],p[1],weight))

        self.graph.add_nodes_from(pairs_id)
        self.graph.add_weighted_edges_from(pairs)

        n_nodes = self.graph.number_of_nodes()
        n_edges = self.graph.number_of_edges()
        print("The constructed graph has %d nodes and %d edges" %(n_nodes, n_edges))


    def search(self, start, goal):
        '''Search for a path in graph given start and goal location
        arguments:
            start - start point coordinate [row, col]
            goal - goal point coordinate [row, col]

        Temporary add start and goal node, edges of them and their nearest neighbors
        to graph for self.graph to search for a path.
        '''
        # Clear previous path
        self.path = []

        # Temporarily add start and goal to the graph
        self.samples.append(start)
        self.samples.append(goal)
        # start and goal id will be 'start' and 'goal' instead of some integer
        self.graph.add_nodes_from(['start', 'goal'])

        ### YOUR CODE HERE ###

        # Find the pairs of points that need to be connected
        # and compute their distance/weight.
        # You could store them as
        # start_pairs = [(start_id, p_id0, weight_s0), (start_id, p_id1, weight_s1), 
        #                (start_id, p_id2, weight_s2) ...]
        start_pairs = []
        goal_pairs = []
        positions = np.array(self.samples)
        kdtree = spatial.KDTree(positions)

        pairs_kd_start=[]
        start_radius = 20
        pairs_kd_start = spatial.KDTree.query_ball_point(kdtree,start,start_radius)
        
        pairs_kd_goal=[]
        goal_radius = 20
        pairs_kd_goal = spatial.KDTree.query_ball_point(kdtree,goal,goal_radius)

        for p in pairs_kd_start:
          if self.check_collision(self.samples[p],start):
                start_pairs.append(('start',p,self.dis(self.samples[p],start)))

        for p in pairs_kd_goal:
            if self.check_collision(self.samples[p],goal):
                goal_pairs.append(('goal',p,self.dis(self.samples[p],goal)))

        # Add the edge to graph
        self.graph.add_weighted_edges_from(start_pairs)
        self.graph.add_weighted_edges_from(goal_pairs)

        # Seach using Dijkstra
        try:
            self.path = nx.algorithms.shortest_paths.weighted.dijkstra_path(self.graph, 'start', 'goal')
            path_length = nx.algorithms.shortest_paths.weighted.dijkstra_path_length(self.graph, 'start', 'goal')
            print("The path length is %.2f" %path_length)
        except nx.exception.NetworkXNoPath:
            print("No path found")
        
        # Draw result
        self.draw_map()

        # Remove start and goal node and their edges
        self.samples.pop(-1)
        self.samples.pop(-1)
        self.graph.remove_nodes_from(['start', 'goal'])
        self.graph.remove_edges_from(start_pairs)
        self.graph.remove_edges_from(goal_pairs)