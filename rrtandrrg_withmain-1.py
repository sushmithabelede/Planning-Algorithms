# -*- coding: utf-8 -*-
"""RRTandRRG_withmain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mtcmTWepbCp9wL01_BT12lW7A3RFSOMG
"""

# Standard Algorithm Implementation
# Sampling-based Algorithms RRT and RRT*
# Class for each tree node
import matplotlib.pyplot as plt
import numpy as np
from numpy.random import randint 
from PIL import Image
import random
import math
import networkx as nx
import matplotlib.pyplot as plt
from scipy import spatial
from math import pi 


def load_map(file_path, resolution_scale):
    ''' Load map from an image and return a 2D binary numpy array
        where 0 represents obstacles and 1 represents free space
    '''
    # Load the image with grayscale
    img = Image.open(file_path).convert('L')
    # Rescale the image
    size_x, size_y = img.size
    new_x, new_y  = int(size_x*resolution_scale), int(size_y*resolution_scale)
    img = img.resize((new_x, new_y), Image.ANTIALIAS)

    map_array = np.asarray(img, dtype='uint8')
    x = np.where(map_array == 1)
    # Get bianry image
    threshold = 127
    map_array = 1 * (map_array > threshold)

    # Result 2D numpy array
    return map_array


class Node:
    def __init__(self, row, col):
        self.row = row        # coordinate
        self.col = col        # coordinate
        self.parent = None    # parent node
        self.cost = 0.0       # cost


# Class for RRT
class RRT:
    # Constructor
    def __init__(self, map_array, start, goal):
        self.map_array = map_array            # map array, 1->free, 0->obstacle
        self.size_row = map_array.shape[0]    # map size
        self.size_col = map_array.shape[1]    # map size

        self.start = Node(start[0], start[1]) # start node
        self.goal = Node(goal[0], goal[1])    # goal node
        self.vertices = []                    # list of nodes
        self.found = False                    # found flag
        self.pos = np.asarray(self.vertices)

    def init_map(self):
        '''Intialize the map before each search
        '''
        self.found = False
        self.vertices = []
        self.vertices.append(self.start)

    
    def dis(self, node1, node2):
        '''Calculate the euclidean distance between two nodes
        arguments:
            node1 - node 1
            node2 - node 2

        return:
            euclidean distance between two nodes
        '''
        
        dx = node1.row - node2.row
        dy = node1.col - node2.col
        d = math.hypot(dx, dy)

        return d

    
    def check_collision(self, node1, node2):
        '''Check if the path between two nodes collide with obstacles
        arguments:
            node1 - node 1
            node2 - node 2

        return:
            True if the new node is valid to be connected
        '''
        ### YOUR CODE HERE ###
        sx = node1.row
        sy = node1.col
        gx = node2.row
        gy = node2.col
        x = sx
        y = sy
        dx = gx - sx
        dy = gy - sy
        theta = math.atan2(gy - sy, gx - sx)
        d = math.hypot(dx, dy)

        n_step = 5*int(d)
        collision = True
        for i in range(n_step):
            D = d*(i+1)/n_step
            x = sx+int(D * math.cos(theta))
            y = sy+int(D * math.sin(theta))
            if (self.map_array[int(x),int(y)] == 0):
              collision = False
        return collision  


    def get_new_point(self, goal_bias):
        '''Choose the goal or generate a random point
        arguments:
            goal_bias - the possibility of choosing the goal instead of a random point

        return:
            point - the new point
        '''
        ### YOUR CODE HERE ###
        rand_pts = np.random.randint(300, size=(2, 100))
        goal_chances = int(goal_bias*100)
        for i in range (goal_chances):
          rand_pts[0,i] = self.goal.row
          rand_pts[1,i] = self.goal.col 

        chosen_point_num = np.random.randint(100,size = (1,1))

        return Node(rand_pts[0,chosen_point_num],rand_pts[1,chosen_point_num])

    def get_nearest_node(self, point):
        '''Find the nearest node in self.vertices with respect to the new point
        arguments:
            point - the new point

        return:
            the nearest node
        '''
        ### YOUR CODE HERE ###
        nodes = self.vertices  
        d = np.zeros([1,len(nodes)])
        for i in range (len(nodes)):
          d[0,i] = self.dis(nodes[i], point)
        nnode_n = np.argmin(d)
        return self.vertices[nnode_n]


    def get_neighbors(self, new_node, neighbor_size):
        '''Get the neighbors that are within the neighbor distance from the node
        arguments:
            new_node - a new node
            neighbor_size - the neighbor distance

        return:
            neighbors - a list of neighbors that are within the neighbor distance 
        '''
        ### YOUR CODE HERE ###

        neighbors = []
        nodes = self.vertices  
        d = np.zeros([1,len(nodes)])
        for i in range (len(nodes)):
          if self.dis(nodes[i], new_node) <= neighbor_size:
            neighbors.append(nodes[i])
        return neighbors
            

    def draw_map(self):
        '''Visualization of the result
        '''
        # Create empty map
        fig, ax = plt.subplots(1)
        img = 255 * np.dstack((self.map_array, self.map_array, self.map_array))
        ax.imshow(img)

        # Draw Trees or Sample points
        for node in self.vertices[1:-1]:
            plt.plot(node.col, node.row, markersize=3, marker='o', color='y')
            plt.plot([node.col, node.parent.col], [node.row, node.parent.row], color='y')
        
        # Draw Final Path if found
        if self.found:
            cur = self.goal
            while cur.col != self.start.col and cur.row != self.start.row:
                plt.plot([cur.col, cur.parent.col], [cur.row, cur.parent.row], color='b')
                cur = cur.parent
                plt.plot(cur.col, cur.row, markersize=3, marker='o', color='b')

        # Draw start and goal
        plt.plot(self.start.col, self.start.row, markersize=5, marker='o', color='g')
        plt.plot(self.goal.col, self.goal.row, markersize=5, marker='o', color='r')

        # show image
        plt.show()

    def draw_map_rrg(self,rrg_vertices):
        '''Visualization of the result
        '''
        # Create empty map
        fig, ax = plt.subplots(1)
        img = 255 * np.dstack((self.map_array, self.map_array, self.map_array))
        ax.imshow(img)

        for node in rrg_vertices[1:None]:
            plt.plot(node.col, node.row, markersize=3, marker='o', color='y')
            i = 0
            if isinstance( node.parent, list):
              for i in length(node.parent):
                # print("parents of node",node,i)
                plt.plot([node.col, node.parent[i].col], [node.row, node.parent[i].row], color='y')
                i = i+1
            else:
              plt.plot(node.col, node.row, markersize=3, marker='o', color='y')
              plt.plot([node.col, node.parent.col], [node.row, node.parent.row], color='y')
              

        # Draw Final Path if found
        if self.found:
            cur = self.goal
            while cur.col != self.start.col and cur.row != self.start.row:
                plt.plot([cur.col, cur.parent.col], [cur.row, cur.parent.row], color='b')
                cur = cur.parent
                plt.plot(cur.col, cur.row, markersize=3, marker='o', color='b')

        # Draw start and goal
        plt.plot(self.start.col, self.start.row, markersize=5, marker='o', color='g')
        plt.plot(self.goal.col, self.goal.row, markersize=5, marker='o', color='r')

        # show image
        plt.show()


    def nearest_points(self,new_node):
      positions = self.pos
      #print(positions)
      kdtreee = spatial.KDTree(positions)
      nearby_points = kdtreee.query_ball_point(np.array([new_node.row,new_node.col]),40)
      nearby_points_coll_free = []
      nearby_points_cost = []
      #print(nearby_points)

      for i in range (len(nearby_points)):
        
        node2 = Node(positions[nearby_points[i]][0],positions[nearby_points[i]][1])
        if self.check_collision(new_node, node2):
          nearby_points_coll_free.append(node2)
          nearby_points_cost.append(self.dis(node2,new_node) + node2.cost)


      near_points_sorted = []
      cost_sorted = []
      sorted_cost_idx = np.argsort(np.asarray(nearby_points_cost))

      for i in range(len(nearby_points_coll_free)):
        near_points_sorted.append(nearby_points_coll_free[sorted_cost_idx[i]])
        cost_sorted.append(nearby_points_cost[sorted_cost_idx[i]])
      #new_node.parents = near_points_sorted
      #new_node.cost = cost_sorted
      #print(nearby_points_coll_free)
      #new_node.parent = nearby_points_coll_free

      return near_points_sorted,cost_sorted


    def rewire(self,new_node,near_points,nearby_points_cost):

      for i in range(len(near_points)):

        a = new_node.cost[0] + self.dis(near_points[i],new_node)
        if a < near_points[i].cost:
            near_points[i].cost = a
            near_points[i].parent = new_node

      

    def RRT(self, n_pts):
      '''RRT main search function
      arguments:
          n_pts - number of points try to sample,
                  not the number of final sampled points

      In each step, extend a new node if possible, and check if reached the goal
      '''
      # Remove previous result
      self.init_map()

      ### YOUR CODE HERE ###
      max_step = 15
      goal_bias = 0.1
      vertices_rrg = []
      vertices_rrg.append(self.start)
      for iterations in range(n_pts):

        new_point = self.get_new_point(goal_bias)
        nearest_node = self.get_nearest_node(new_point)
        d = self.dis(new_point, nearest_node)

        if d <= max_step:
          new_node = new_point
        else:
          sx = nearest_node.row
          sy = nearest_node.col
          gx = new_point.row
          gy = new_point.col
          x = sx
          y = sy
          dx = gx - sx
          dy = gy - sy
          theta = math.atan2(gy - sy, gx - sx)
          d = math.hypot(dx, dy)

          '''
          if self.check_collision(Node(sx+int(d/2 * math.cos(theta)),int(sy+d/2 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/2 * math.cos(theta)),sy+int(d/2 * math.sin(theta)))
          elif self.check_collision(Node(sx+int(d/5 * math.cos(theta)),int(sy+d/5 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/3 * math.cos(theta)),sy+int(d/3 * math.sin(theta)))
          elif self.check_collision(Node(sx+int(d/7 * math.cos(theta)),sy+int(d/7 * math.sin(theta))) ,nearest_node):
            new_node = Node(sx+int(d/4 * math.cos(theta)),sy+int(d/4 * math.sin(theta)))
          else: continue 
          '''

          if self.check_collision(Node(sx+int(d/3 * math.cos(theta)),int(sy+d/3 * math.sin(theta))) ,nearest_node) and (self.dis(Node(sx+int(d/3 * math.cos(theta)),int(sy+d/3 * math.sin(theta))) , nearest_node) >= 7):
            new_node = Node(sx+int(d/3 * math.cos(theta)),sy+int(d/3 * math.sin(theta)))
          else: continue

          self.vertices.append(new_node)
          if len(self.pos)>0:
            near_points,near_points_cost = self.nearest_points(new_node)
            new_node_rrg = new_node

            if len(near_points) <= 1:
              new_node_rrg.parent = nearest_node
              new_node_rrg.cost = self.dis(nearest_node,new_node) + new_node.parent.cost 
              
              vertices_rrg.append(new_node_rrg)
              #print("aarraayyy cost",new_node_rrg.cost)
            else:              

              new_node_rrg.parent = near_points
              #print('nearointssssss',near_points)
              new_node_rrg.cost = near_points_cost

              #print("aarraayyy cost",near_points_cost_array)
              #print(new_node_rrg.cost)
              self.rewire(new_node,near_points,near_points_cost)
              vertices_rrg.append(new_node_rrg)
            #print('rrg nodes are these many in number: ',vertices_rrg[len(near_points)].cost)


          self.pos = []
          for i in range(len(self.vertices)):
            self.pos.append((self.vertices[i].row,self.vertices[i].col))
          self.pos = np.asarray(self.pos)
          new_node.parent = nearest_node
          new_node.cost = self.dis(nearest_node,new_node) + new_node.parent.cost 
          goal_dis = self.dis(new_node,self.goal)
          if goal_dis < max_step:
              goal_coll = self.check_collision(new_node,self.goal)
              if goal_coll == True:
                  self.found=True
                  self.vertices.append(self.goal)
                  self.goal.parent = new_node
                  self.goal.cost = goal_dis+new_node.cost

                  vertices_rrg.append(self.goal)
                  
                  break

      # We have the neighbors in the ball and the new node. 
      # new node has multiple parents with multiple costs. 
      #all we need to do now is backtrack and find the optimal path! 
      print('vertices_rrg',len(vertices_rrg))
      print('normal vertices',len(self.vertices))



    
      if self.found:
        steps = len(self.vertices) - 2
        length = self.goal.cost
        print("It took %d nodes to find the current path" % steps)
        print("The path length is %.2f" % length)
      else:
        print("No path found")

      # Draw result
      self.draw_map()
      self.draw_map_rrg(vertices_rrg)

if __name__ == "__main__":
  # Load the map
  start = (210, 75)
  goal  = (30, 240)
  map_array = load_map("/content/WPI_map.jpg", 0.3)
  N = Node(20,30)
  N1 = Node(30,40)
  print(N.col)

  RRT_1 = RRT(map_array,start,goal)
  
  d = RRT_1.dis(N,N1)
  print(d)
  

  # Planning class
  #PRM_planner = PRM(map_array)
  RRT_planner = RRT(map_array, start, goal)

  # Search with PRM


  # Search with RRT and RRT*
  RRT_planner.RRT(n_pts=1000)
  #RRT_planner.RRT_star(n_pts=2000)